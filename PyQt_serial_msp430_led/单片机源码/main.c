#include <msp430x14x.h>
#include "Config.h"                     //开发板配置头文件，主要配置IO端口信息

uchar flag, zlag, hig=0xff, lig=10, xlag;

//***********************************************************************
//             TIMERA初始化，设置为UP模式计数
//***********************************************************************
void TIMERA_Init(void)                                   //连续计数模式，计数到0XFFFF产生中断
{
  TACTL |= TASSEL1 + TACLR + ID0 + ID1 + MC0+MC1 + TAIE;     //SMCLK做时钟源，8分频，连续计数模式，计数到0XFFFF，开中断
  CCR0 = lig;
}

//***********************************************************************
//             TIMERA中断服务程序，需要判断中断类型
//***********************************************************************
#pragma vector = TIMERA1_VECTOR
__interrupt void Timer_A(void)
{
  switch(TAIV)                                  //需要判断中断的类型
  {
  case 2:break;
  case 4:break;
  case 10:if(flag) {P6OUT |= BIT0;CCR0=hig; flag=0;}else {P6OUT &= ~BIT0;flag=1;CCR0=lig;} break;
 
  }
}


//***********************************************************************
//               MSP430IO口初始化
//***********************************************************************
void Port_Init()
{
  LED8DIR  = 0xFF;                      //设置IO口方向为输出
  LED8 = 0xFF;                      //P6口初始设置为FF
}

//*************************************************************************
//               MSP430串口初始化
//*************************************************************************
void UART_Init()
{
  U0CTL|=SWRST + CHAR;                //复位SWRST，8位数据模式
  U0TCTL|=SSEL1;                      //SMCLK为串口时钟
  U0BR1=baud_h;                       //BRCLK=8MHZ,Baud=BRCLK/N
  U0BR0=baud_l;                       //N=UBR+(UxMCTL)/8
  U0MCTL=0x00;                        //微调寄存器为0，波特率9600bps
  ME1|=UTXE0;                         //UART0发送使能
  ME1|=URXE0;                         //UART0接收使能
  U0CTL&=~SWRST;
  IE1|=URXIE0;                        //接收中断使能位
  
  P3SEL|= BIT4 + BIT5;                //设置IO口为第二功能模式，启用UART功能
  P3DIR|= BIT4;                       //设置TXD0口方向为输出
}

//*************************************************************************
//              串口0发送数据函数
//*************************************************************************

void Send_Byte(uchar data)
{
  while(!(IFG1&UTXIFG0));          //发送寄存器空的时候发送数据
    U0TXBUF=data;
}

//*************************************************************************
//              串口0发送字符串函数
//*************************************************************************
void Print_Str(uchar *s)
{
    while(*s != '\0')
    {
        Send_Byte(*s++);
    }
}

//*************************************************************************
//               处理来自串口0的接收中断
//*************************************************************************

#pragma vector=UART0RX_VECTOR
__interrupt void UART0_RX_ISR(void)
{
  uchar data=0;
  data=U0RXBUF;                       //接收到的数据存起来
  
  if('z' == data)
  {
    zlag = !zlag;
    return;
  }
  else if('x' == data)
  {
    xlag = !xlag;
    return;
  }
  
  if(zlag)
  {
    hig=data;
    return;
  }
  if(xlag)
  {
    lig=data;
    return;
  }
  
  if('r' == data)
  {
    data = ~LED8;
    Send_Byte(data);
  }
  else
  {
    LED8 = ~data;                    //将收到的数据显示在8个LED灯上显示，仅限16进制
  }
}

//*************************************************************************
//           主函数
//*************************************************************************
void main(void)
{ 
  WDT_Init();                         //看门狗设置
  Clock_Init();                       //系统时钟设置
  Port_Init();                        //LED端口初始化
  UART_Init();                        //串口设置初始化
 
  TIMERA_Init();
  _EINT();                            //开中断
  while(1)                            //无限循环
    {
      
    }
}
